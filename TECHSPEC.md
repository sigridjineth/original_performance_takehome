# Anthropic 성능 평가 챌린지: 방법론 정리 & Sub-1000 Tech Spec

> **원칙:** 아래 방법론들은 모두 동등하게 중요하며, 단독으로는 충분하지 않습니다.  
> **목표:** 모든 방법을 동시에 고려해, 병목을 다층적으로 제거해 나갑니다.

---

## 0. 전제 및 용어

- **목표 사이클:** `tests/submission_tests.py` 기준 **1000 미만**
- **기본 가정(전략 텍스트 기반):**
  - VLIW 구조, 각 엔진(ALU/VALU/LOAD/STORE/FLOW)에 **슬롯 제한**
  - SIMD 폭: **VLEN=8**
  - **LOAD 슬롯 2/cycle** (로드 대역폭이 병목)
  - **쓰기는 사이클 끝에 반영**되어 같은 사이클 읽기 불가
  - `Scratchpad`는 실질적인 “대형 레지스터 파일”로 사용 가능
- **중요 원칙:** 테스트 파일 변경 없이 성능 개선  
  - `git diff origin/main tests/` 비어 있음

---

# 1. 방법론 총정리 (모두 동등 중요)

아래 방법론은 **동일한 중요도**로 취급되며, 각 방법이 다른 병목을 제거합니다.

---

## 1) VLIW 슬롯 포화 & 정적 스케줄링

**핵심 목적:** 한 사이클 내 모든 엔진 슬롯을 가능한 한 꽉 채워 유휴 시간을 제거

**주요 기법**
- **DAG 기반 리스트 스케줄링**
- **크리티컬 패스 우선**
- **백트래킹 기반 NOP 최소화**
- **슬롯 유연성(slot-flexible) 활용**
- **슈퍼블록/트레이스 스케줄링**

**구현 포인트**
- micro-op DAG 구성  
- Ready queue 운영  
- 엔진별 슬롯 제약과 데이터 의존성 동시에 만족  
- 패킹 실패 시 재시도(백트래킹)

**검증 지표**
- 엔진별 슬롯 활용률(%)  
- 사이클 당 NOP 수

---

## 2) 소프트웨어 파이프라이닝 (Modulo Scheduling)

**핵심 목적:** 여러 이터레이션을 겹쳐 처리해 처리량 극대화

**주요 기법**
- **Modulo Scheduling**
- **Swing Modulo Scheduling**
- **프로로그/에필로그 최소화**
- **프레디케이션을 통한 경계 제거**

**구현 포인트**
- 6-스테이지 해시를 서로 다른 이터레이션에 분산  
- **II(Initiation Interval) 최소화**  
- 레지스터 수명 최소화

**검증 지표**
- II 값  
- 파이프라인 버블 비율

---

## 3) 로드 병목 완화: Broadcast + 재사용

**핵심 목적:** 2-load/cycle 병목을 줄이거나 숨기기

**주요 기법**
- **브로드캐스트 로드**
- **라운드별 엔트로피 기반 전략 전환**
- **벡터 재사용 및 캐싱**

**구현 포인트**
- 라운드마다 “고유 인덱스 수”에 따라 로드 전략 선택  
- 브로드캐스트 가능한 구간은 그룹화 전략 사용  
- 고엔트로피 구간은 희소 로드 + 계산 오버랩

**검증 지표**
- 브로드캐스트 성공률  
- LOAD 슬롯 유휴율

---

## 4) Scratchpad 상주 전략 (Register Residency)

**핵심 목적:** 메모리 왕복 제거로 LOAD/STORE 슬롯 확보

**주요 기법**
- **초기 vload로 입력 전체를 Scratchpad로 이동**
- **중간 라운드에서 메모리 접근 제거**
- **마지막에 vstore로 결과 출력**

**구현 포인트**
- 입력/출력만 메모리에 접근  
- Scratchpad를 실질적 레지스터 파일처럼 사용  
- 라운드 간 데이터 재사용 극대화

**검증 지표**
- 라운드 중 메모리 접근 횟수  
- Store 슬롯 사용률

---

## 5) 해시 연산 접기 & 특수 명령 활용

**핵심 목적:** 연산 수와 의존성을 줄여 VALU 효율 극대화

**주요 기법**
- `(a << k) + a + const → multiply_add` 접기
- 상수 벡터 고정(초기화 후 재사용)
- 단계별 의존성 분리

**구현 포인트**
- Stage0/2/4 등에 특수 명령 적용  
- 상수는 매번 로드하지 않고 벡터 상수 레지스터 사용  
- 연산 수 자체를 감소

**검증 지표**
- 해시 스테이지당 명령 수  
- VALU 슬롯 활용률

---

## 6) 분기 제거 & 프레디케이션

**핵심 목적:** 분기 비용과 파이프라인 스톨 제거

**주요 기법**
- `val % 2 → val & 1`  
- `select` → 산술 변환  
- 프레디케이션으로 경계 조건 제거  
- If-conversion, hyperblock 기법

**구현 포인트**
- 제어 흐름을 데이터 흐름으로 치환  
- 분기 없는 선형 코드 유지

**검증 지표**
- 분기 명령 수  
- 파이프라인 스톨 비율

---

## 7) 조기 예측 & 추측 실행 (Speculation)

**핵심 목적:** 메모리 지연을 계산 뒤로 숨김

**주요 기법**
- Stage4 중간 비트로 Stage5 분기 예측 (가정)  
- 추측성 prefetch  
- 예측 실패 대비 안전 경로

**구현 포인트**
- 예측 정확도 실험 필요  
- 실패 시 프레디케이션으로 안전성 확보  
- 성공 시 로드 지연 대부분 은폐

**검증 지표**
- 예측 정확도  
- 유효한 prefetch 비율

---

## 8) 데이터 레이아웃 재구성 (SoA / AoSoA)

**핵심 목적:** SIMD 로드 효율 극대화

**주요 기법**
- AoS → SoA  
- VLEN=8에 맞춘 AoSoA  
- 64B 정렬 + 패딩

**구현 포인트**
- 동일 필드의 연속 벡터 로드 확보  
- 뱅크 충돌 방지용 패딩

**검증 지표**
- 연속 vload 비율  
- 분할 로드 발생 빈도

---

## 9) 레지스터 압박/스필 제거

**핵심 목적:** 스필이 로드 병목을 악화시키는 것을 방지

**주요 기법**
- 그래프 컬러링 관점의 수명 관리  
- 라이브 레인지 분할  
- 재계산 vs 저장 전략

**구현 포인트**
- 고빈도 변수 상주시킴  
- 임시 변수 재사용  
- 스필은 가장 마지막 수단

**검증 지표**
- 스필 횟수  
- 스필로 인한 LOAD/STORE 빈도

---

## 10) 도구화 (스케줄러/번들러 제작)

**핵심 목적:** 성능을 “재현 가능하고 확장 가능한 방식”으로 확보

**주요 기법**
- 자동 스케줄러 구축  
- DAG 기반 스케줄링  
- 엔진별 슬롯 패킹 자동화

**구현 포인트**
- 수작업 최적화 대신 자동화 기반  
- 반복 실험/튜닝이 가능하도록 설계

**검증 지표**
- 자동 생성 번들의 슬롯 활용률  
- 수작업 대비 사이클 개선

---

## 11) 확장적/전이 기법 (중국 HPC/CTF/컴파일러 연구 기반)

**핵심 목적:** 직접적 적용 여부와 무관하게 “최적화 사고방식” 확대

**주요 기법**
- 모듈로 스케줄링 파생 기법 (UTBPC)  
- VLIW 패킷 구조 이해  
- 레지스터 할당/스필 최적화  
- 극단적 instruction density 최적화

**적용 방식**
- 직접 적용 가능성 여부를 실험적으로 판단  
- 코드 생성/스케줄링 정책에 통합 가능성 검토

---

# 2. Sub-1000 Cycles 테크 스펙

> 모든 방법론을 **동등한 중요도**로 반영해 설계한다.

---

## 2.1 목표 및 성공 기준

**목표**
- `tests/submission_tests.py` 기준 **< 1000 cycles**

**성공 기준**
- 테스트 파일 변경 없음  
- 슬롯 활용률, 로드 유휴율, 스필 횟수, II 값 등 핵심 지표 개선  
- 트레이스 스냅샷 제공 가능

---

## 2.2 아키텍처 모델 (가정)

- VLIW 엔진: ALU / VALU / LOAD / STORE / FLOW  
- SIMD 폭: 8  
- LOAD 슬롯: 2/cycle  
- 쓰기 반영은 사이클 종료 시점  
- Scratchpad는 메모리 병목 완화 수단

---

## 2.3 설계 구성요소

### A) 스케줄러/번들러

**입력**
- micro-op DAG  
- 엔진별 슬롯 제한  
- 데이터 의존성 정보

**출력**
- 사이클별 번들 구조  
  - `{alu:[...], valu:[...], load:[...], store:[...], flow:[...]}`

**스케줄링 알고리즘 (개념)**

```pseudo
ready = nodes with no unsatisfied deps
cycle = 0
while ready not empty:
  bundle = empty slots
  while slots remain and ready not empty:
    pick node by criticality + resource fit
    schedule node in bundle if feasible
  commit bundle
  update deps; push newly-ready nodes
  cycle++
```

**검증**
- 슬롯 활용률 보고  
- NOP 최소화 성능 확인

---

### B) 소프트웨어 파이프라이닝

- 해시 6단계를 다중 이터레이션에 분산  
- II=1~2 목표  
- 프레디케이션으로 프로로그/에필로그 제거

**검증**
- 파이프라인 버블 비율  
- II 측정

---

### C) 메모리 전략

**기본**
- 입력을 Scratchpad로 올리고 라운드 간 메모리 접근 제거  
- 마지막에만 출력

**로드 스케줄**
- 저엔트로피 라운드: 브로드캐스트  
- 고엔트로피 라운드: 희소 로드 + 계산 오버랩  
- 중간 구간: 하이브리드

**검증**
- LOAD 유휴율 < 10%  
- 브로드캐스트 성공률

---

### D) 해시 최적화

- `(a << k) + a + const → multiply_add`  
- 상수는 벡터 상수 레지스터로 고정  
- 스테이지 간 의존성 분리

**검증**
- 해시 스테이지당 명령 수 감소  
- VALU 슬롯 활용률

---

### E) 인덱스 업데이트/분기 제거

- `%` 제거 → `&1` 사용  
- `select` 제거 → 산술 결합  
- 리프 라운드는 wrap 고정 가능성 검토

**검증**
- FLOW/branch 명령 감소  
- 파이프라인 스톨 감소

---

### F) 추측 실행 (가정 기반)

- 중간 비트로 최종 분기 예측 (가정)  
- 예측 성공 시 prefetch로 지연 은폐  
- 실패 시 안전 경로 유지

**검증**
- 예측 정확도  
- 성능 영향 평가

---

### G) 데이터 레이아웃

- SoA 또는 AoSoA  
- VLEN=8 정렬  
- 64B 정렬

**검증**
- 연속 vload 비율  
- 분할 로드 감소

---

### H) 레지스터 압박/스필 제거

- 고빈도 변수 고정  
- 임시 변수 수명 최소화  
- 필요 시 재계산 vs 저장 비교

**검증**
- 스필 횟수  
- 스필로 인한 LOAD/STORE 빈도

---

## 2.4 성능 측정 및 검증

**필수 측정**
- submission_tests 사이클  
- 엔진별 슬롯 활용률  
- LOAD 유휴율  
- 스필 횟수  
- II 값

**보조 측정**
- 트레이스 그래프  
- 해시 스테이지별 명령 수  
- 브로드캐스트 성공률

---

## 2.5 리스크 및 대응

| 리스크 | 대응 |
|---|---|
| 추측 실행 실패 | 안전 경로 유지, 실험 기반 활성화 |
| 스필 증가 | 라이브 레인지 최적화 |
| 브로드캐스트 효과 미흡 | 라운드별 전략 자동 선택 |
| 슬롯 포화 실패 | 스케줄러 비용 함수 조정 |

---

## 2.6 결과물

- 최적화된 커널 코드  
- 스케줄러/번들러 코드  
- submission_tests 로그  
- 트레이스 스냅샷  
- 간단한 최적화 보고서

---

# 3. 요약

- **모든 방법론은 동등하게 중요**하며, 병목을 다른 층에서 제거합니다.  
- Sub-1000은 **단일 테크닉**이 아니라 **멀티 레벨 통합**으로 달성합니다.  
- 문서화된 지표(슬롯 활용률, II, 로드 유휴율 등)를 통해 개선 여부를 객관화합니다.
